"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inlinePositionParser = void 0;
var debug_1 = require("../../debug");
var d = (0, debug_1.debug)("GitLab inlinePositionParser");
function inlinePositionParser(structuredDiff, path, line) {
    d("structuredDiff", structuredDiff);
    var lineDiff = calculateLineDiff(structuredDiff, line);
    return {
        pathDiff: {
            oldPath: structuredDiff.fromPath,
            newPath: path,
        },
        lineDiff: lineDiff,
    };
}
exports.inlinePositionParser = inlinePositionParser;
function calculateLineDiff(diff, line) {
    var chunk = findRelevantChunk(diff, line);
    d("calculateLineDiff found chunk", { line: line, chunk: chunk, changes: chunk === null || chunk === void 0 ? void 0 : chunk.changes });
    if (!chunk) {
        return {
            oldLine: line,
            newLine: line,
        };
    }
    if (chunk.newStart <= line && line <= chunk.newStart + chunk.newLines) {
        var change = chunk.changes.find(function (change) {
            switch (change.type) {
                case "add":
                    return change.ln === line;
                case "del":
                    return false;
                case "normal":
                    return change.ln2 === line;
            }
        });
        // If there is no relevant change we return the requested line.
        if (!change || change.type === "del") {
            return {
                oldLine: line,
                newLine: line,
            };
        }
        switch (change.type) {
            case "add":
                return {
                    oldLine: undefined,
                    newLine: change.ln,
                };
            case "normal":
                return {
                    oldLine: change.ln1,
                    newLine: change.ln2,
                };
        }
    }
    else if (line < chunk.newStart) {
        d("calculateLineDiff line below changes in file", { line: line });
        return {
            oldLine: line,
            newLine: line,
        };
    }
    else {
        var offset = chunk.newStart + chunk.newLines - (chunk.oldStart + chunk.oldLines);
        d("calculateLineDiff line above changes in file", { line: line, offset: offset });
        return {
            oldLine: line - offset,
            newLine: line,
        };
    }
}
// Find the most relevant chunk using a binary search approach.
// A chunk containing changes with the line is preferred.
// If none exists then a chunk with the nearest newStart below the line is preferred.
// Only if no other chunks exists is the first chunk above the line returned.
function findRelevantChunk(diff, line) {
    var chunks = diff.chunks;
    if (chunks.length == 0) {
        return undefined;
    }
    var startIndex = 0;
    var endIndex = chunks.length - 1;
    while (true) {
        var currentIndex = Math.floor((startIndex + endIndex) / 2);
        var currentChunk = chunks[currentIndex];
        if (chunkContainsLine(currentChunk, line)) {
            return currentChunk;
        }
        if (currentIndex === startIndex) {
            var endChunk = chunks[endIndex];
            if (!endChunk) {
                return currentChunk;
            }
            if (chunkContainsLine(endChunk, line)) {
                return endChunk;
            }
            if (endChunk.newStart < line) {
                return endChunk;
            }
            if (currentChunk.newStart < line) {
                return currentChunk;
            }
            var currentChunkOffset = Math.abs(currentChunk.newStart - line);
            var endChunkOffset = Math.abs(endChunk.newStart - line);
            if (currentChunkOffset <= endChunkOffset) {
                return currentChunk;
            }
            else {
                return endChunk;
            }
        }
        if (currentChunk.newStart < line) {
            startIndex = currentIndex;
        }
        else {
            endIndex = currentIndex;
        }
    }
}
function chunkContainsLine(chunk, line) {
    return chunk.newStart <= line && line <= chunk.newStart + chunk.newLines;
}
//# sourceMappingURL=inlinePositionParser.js.map